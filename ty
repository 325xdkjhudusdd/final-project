void clear()
{
	int i, j, k, m = 0;

	for (i = point_y + 3; i >= point_y; i--)
	{
		for (j = 1; j < 16; j++)
		{
			if (0 == scope[j][i])
			{
				break;
			}
		}

		if (16 == j)
		{
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY);

			m++;

			for (k = i; k > 3; k--)
			{
				for (j = 1; j < 16; j++)
				{
					scope[j][k] = scope[j][k - 1];
					gotoxy(j * 2, k);

					if (1 == scope[j][k])
					{
						printf("■");
					}

					else
					{
						printf(" ");
					}
				}
			}

			for (j = 1; j < 16; j++)
			{
				scope[j][4] = 0;
			}
			i++;
		}
	}

	switch (m) //判斷一次消除了幾行，來設置得分數
	{
	case 1: fen += 100;

		break;

	case 2: fen += 230;

		break;

	case 3: fen += 438;

		break;

	case 4: fen += 854;

		break;

	default:;

	}

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);//黑底亮黃色字。

	gotoxy(40, 3);

	printf("分 數： %d", fen);

	for (j = 7; j < 11; j++)
	{
		if (1 == scope[j][1])
			gameover();
	}
}

//隨機出現方塊

void my_randout()
{
	int i, j;

	switch (rand() % 7)
	{
	case 0:for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block0[i][j];

		break;

	case 1: for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block1[i][j];

		break;

	case 2: for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block2[i][j];

		break;

	case 3: for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block3[i][j];

		break;

	case 4: for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block4[i][j];

		break;

	case 5: for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block5[i][j];

		break;

	case 6: for (i = 0; i < 4; i++)

		for (j = 0; j < 4; j++)

			block[i][j] = block6[i][j];

		break;

	default:;
	}

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			tem[i][j] = block[i][j];
		}
	}

	switch (rand() % 4)//再設置隨機旋轉的方向
	{
	case 0:

		break;

	case 1: for (i = 0; i < 4; i++)//順時針90度
	{
		for (j = 0; j < 4; j++)
		{
			block[j][3 - i] = tem[i][j];
		}
	}
			break;

	case 2: for (i = 0; i < 4; i++)//順180度
	{
		for (j = 0; j < 4; j++)
		{
			block[3 - i][3 - j] = tem[i][j];
		}
	}
			break;

	case 3: for (i = 0; i < 4; i++)//順270度
	{
		for (j = 0; j < 4; j++)
		{
			block[3 - j][i] = tem[i][j];
		}
	}
			break;

	default:;
	}
	//列印提示區的方塊

}

//顯示方格

void my_printblock()
{
	int i, j;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			if (point_x / 2 + j > 0)
			{
				if (1 == scope[point_x / 2 + j][point_y + i])
				{
					SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY);
					gotoxy(point_x + j * 2, point_y + i);
					printf("■");
				}
				else if (1 == BLOCK[i][j])
				{
					SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
					gotoxy(point_x + j * 2, point_y + i);
					printf("■");
				}
			}
		}
	}
}

//遊戲結束

void gameover()
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
	gotoxy(4, 10); printf(" ");
	gotoxy(4, 11); printf(" ■■■■ ■    ■ ■■■■ ■■■■ ");
	gotoxy(4, 12); printf(" ■    ■ ■    ■ ■       ■    ■ ");
	gotoxy(4, 13); printf(" ■    ■ ■    ■ ■■■■ ■■■■ ");
	gotoxy(4, 14); printf(" ■    ■  ■  ■  ■       ■ ■ ");
	gotoxy(4, 15); printf(" ■■■■   ■■   ■■■■ ■  ■■");
	gotoxy(4, 16); printf(" ");
	gotoxy(32, 17); printf("空格鍵：重來\tEsc：退出");
	switch (_getch())
	{
	case 32: system("cls");//清屏
		console();
		my_print();//輸出介面
		my_randout();
		memset(scope, 0, sizeof(int) * 25 * 34);//數組清零
		fen = 0;
		break;
	case 27: exit(0);
		break;
	default:;
	}
}
